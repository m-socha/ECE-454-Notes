\documentclass[12pt,titlepage]{article}
\usepackage[margin=1in]{geometry}

\begin{document}
  \begin{titlepage}
    \vspace*{\fill}
    \centering

    \textbf{\Huge ECE 454 Course Notes} \\ [0.4em]
    \textbf{\Large Distributed Computing} \\ [1em]
    \textbf{\Large Michael Socha} \\ [1em]
    \textbf{\large 4A Software Engineering} \\
    \textbf{\large University of Waterloo} \\
    \textbf{\large Spring 2018} \\
    \vspace*{\fill}
  \end{titlepage}

  \newpage 

  \tableofcontents

  \newpage

  \section{Course Overview}
    \subsection{Logistics}
      \begin{itemize}
        \item \textbf{Professor:} Wojciech Golab
        \item \textbf{Email:} wgolab@uwaterloo.ca
      \end{itemize}

  \section{Introduction}
    \subsection{What is a Distributed System?}
      A distributed system is a collection of autonomous computing elements that appear to its users to be a single coherent system.

    \subsection{Rationale Behind Distributed Systems}
      \begin{itemize}
        \item Resource sharing
        \item Integrating multiple systems
        \item Centralized systems may not be as effective as many smaller systems working together
        \item Users themselves may be mobile and distributed physically from one another
      \end{itemize}

    \subsection{Middleware}
      Middleware is a layer of software that separates applications from their underlying platform. Middleware is often used by distributed
      systems to support heterogeneous computers and networks while offering a single-system view. Common middleware services include:
      \begin{itemize}
        \item Communication (e.g. add job to remote queue)
        \item Transactions (e.g. access multiple independent services atomically)
        \item Service composition (e.g. Independent map system enhanced with independent weather forecast system)
        \item Reliability (e.g. replicated state machine)
      \end{itemize}

    \subsection{Goals of Distributed Systems}
      \subsubsection{Supporting Resource Sharing}
        Resources can include:
        \begin{itemize}
          \item Peripheral devices (e.g. printers, video cameras)
          \item Storage facilities (e.g. file servers)
          \item Enterprise data (e.g. payroll)
          \item Web page (e.g. Web search)
          \item CPUs (e.g. Supercomputers)
        \end{itemize}

      \subsubsection{Making distribution transparent}
        Distribution transparency attempts to hide that processes and resources are physically distributed. Types of transparency include:
        \begin{itemize}
          \item \textbf{Access:} Hide differences in data representation and how data is accessed
          \item \textbf{Location:} Hide where resource is located
          \item \textbf{Migration:} Hide that a resource may move to another location
          \item \textbf{Relocation:} Hide that a resource may move to another location while in use
          \item \textbf{Replication:} Hide that a resource is replicated
          \item \textbf{Concurrency:} Hide that a resource may be shared by users competing for that resource
          \item \textbf{Failure:} Hide the failure and recovery of a resource
        \end{itemize}

      \subsubsection{Being Open}
        An open distributed system offers components that can be easily used by or integrated into other systems. Key properties of openness
        include:
        \begin{itemize}
          \item Interoperability
          \item Composability
          \item Extensibility
          \item Separation of policy from mechanism
        \end{itemize}

      \subsubsection{Being Scalable}
        Scalability covers a system's ability to expand along three axes:
        \begin{itemize}
          \item Size (e.g. adding users and resources)
          \item Geography (e.g. users across large distances)
          \item Administration (e.g. multiple independent admins)
        \end{itemize}
        Centralized systems tend to have limited scalability.

        A few common scaling techniques include:
        \begin{itemize}
          \item Hiding communication latencies (i.e. trying to avoid waiting for responses from remote-server machines)
          \item Partitioning (i.e. Taking a component, splitting it into smaller parts, and spreading those parts across the system)
          \item Replication (i.e. Adding multiple copies of a component to increase availability, balance load, support caching, etc.)
        \end{itemize}

      \subsection{Common Fallacies of Distributed Computing}
        The following are common beginner assumptions that can lead to major trouble:
        \begin{itemize}
          \item The network is reliable
          \item The network is secure
          \item The network is homogeneous
          \item The network topology is static
          \item Latency is 0
          \item Bandwidth is unlimited
          \item Transport cost is 0
          \item There is one administrator
        \end{itemize}

      \subsection{Types of Distributed Systems}
        \begin{itemize}
          \item \textbf{Web sites and Web services}
          \item \textbf{High performance computing (HPC):} High-performance computing in distributed memory settings, where message communication is used instead of shared memory.
          \item \textbf{Clustered Computing:} Distributing CPU or I/O intensive tasks over multiple servers.
          \item \textbf{Cloud and Grid Computing:} Grid computing focuses on combining resources from different institutions, while cloud computing provides access to shared pools
          of configurable system resources.
          \item \textbf{Transaction Processing:} Distributed transactions coordinated by transaction processing (TP) monitor.
          \item \textbf{Enterprise Application Integration (EAI):} Middleware often used as communication facilitator in such systems.
          \item \textbf{Sensor Networks:} Each sensor in a network can process and store data, which can be queries by some operator. Sensors often rely on in-network data
          processing to reduce communication costs.
        \end{itemize}

  \section{Architectures}
    \subsection{Definitions}
      \begin{itemize}
        \item \textbf{Component:} A modular unit with a well-defined interface
        \item \textbf{Connector:} Mechanism that mediated communication, coordination, or cooperation among components
        \item \textbf{Software architecture:} Organization of software components
        \item \textbf{System architecture:} Instantiation of software architecture in which software components are placed on real machines
        \item \textbf{Autonomic System:} System that adapts to its environment by monitoring its own behavior and reacting accordingly
      \end{itemize}

    \subsection{Architectural Styles}
      \subsubsection{Layered}
        Control flows from layer-to-layer; requests flow down the hierarchy and responses flow up, with each layer only interacting with its two neighboring layers.
        Layered architectures are often used to support client-server interactions, where a client component requests a service from a server component and waits for
        a response. Many enterprise systems are organized intro three layers, namely a user interface, application layer, and database. Note that middle layers may
        act as a client to the layer below and a server to the layer above.

        Vertical distribution describes the logical layers of a system being organized as separate physical tiers. Horizontal distribution describes a single logical
        layer being split across multiple machines.

      \subsubsection{Object-Based Architecture}
        Components are much more loosely organized than in a layered architecture, with components being able to interact freely with one another and no strict concept
        of layer.

      \subsubsection{Data-Centered Architecture}
        Components communicate by using a shared data repository, such as a database or file system.

      \subsubsection{Event-Based Architecture}
        Components communicate by sharing events. Publish/subscribe systems can be used for sharing news, balancing workloads, asynchronous workflows, etc.        

      In practice, many systems are hybrids of the architectures listed above.

    \subsection{Self-Management:}
      Self-managing systems can be constructed using a feedback loop that monitors system behaviors and adjusts the system's internal operation.

  \section{Processes}
    \subsection{Controlling Processes in Linux}
      Below are some useful command:
      \begin{itemize}
        \item ps - lists running processes
        \item top - lists processes with top resource usage
        \item kill / pkill / killall - used to terminate processes
        \item jobs - lists currently running jobs
        \item bg - backgrounds a job
        \item fg - foregrounds a job
        \item nice / renice - sets priority of processes
        \item CTRL-C - stops job in terminal
        \item CTRL-Z - suspends job in terminal (use fg or bg to resume)
      \end{itemize}

    \subsection{Context Switching During IPC}
      Inter-process communication can be used to help coordinate processes. However, IPS can be costly, since it requires a context switch from user to
      kernel space and back.

    \subsection{Threads}
      Threads execution the same process can communicate through shared memory. Threads are sometimes referred to as lightweight processes (LWPs).
      Multithreading applications often follow a dispatcher/worker design, where a dispatcher thread received requests and feeds them to a pool
      of worker threads.

    \subsection{Hardware and Software Interfaces}
      Processes and threads may interact with underlying hardware either directly through processor instructions or indirectly through library functions
      operating system calls. The general layers of interaction (from more abstract to less) are applications, libraries, operating system and hardware.
      These layers may interact with any layer below. Distributed systems often run in virtual environments that manage interactions with lower layers.
      A major benefit of such virtualization is improved portability. Virtual machine monitors can offer additional benefits, including server consolidation,
      live migration of VMs to support load balancing and proactive maintenance, and VM replication.

    \subsection{Interfaces in Network Systems}
      Networked applications communicate by exchanging messages. The format of these messages is determined by a message-passing protocol.

    \subsection{Server Clusters}
      Servers in a cluster are often organized in three physical tiers. The first is a load balancer, followed by application servers followed by a database
      or file system.

\end{document}

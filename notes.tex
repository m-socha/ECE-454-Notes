\documentclass[12pt,titlepage]{article}
\usepackage[margin=1in]{geometry}

\begin{document}
  \begin{titlepage}
    \vspace*{\fill}
    \centering

    \textbf{\Huge ECE 454 Course Notes} \\ [0.4em]
    \textbf{\Large Distributed Computing} \\ [1em]
    \textbf{\Large Michael Socha} \\ [1em]
    \textbf{\large 4A Software Engineering} \\
    \textbf{\large University of Waterloo} \\
    \textbf{\large Spring 2018} \\
    \vspace*{\fill}
  \end{titlepage}

  \newpage 

  \tableofcontents

  \newpage

  \section{Course Overview}
    \subsection{Logistics}
      \begin{itemize}
        \item \textbf{Professor:} Wojciech Golab
        \item \textbf{Email:} wgolab@uwaterloo.ca
      \end{itemize}

  \section{Introduction}
    \subsection{What is a Distributed System?}
      A distributed system is a collection of autonomous computing elements that appear to its users to be a single coherent system.

    \subsection{Rationale Behind Distributed Systems}
      \begin{itemize}
        \item Resource sharing
        \item Integrating multiple systems
        \item Centralized systems may not be as effective as many smaller systems working together
        \item Users themselves may be mobile and distributed physically from one another
      \end{itemize}

    \subsection{Middleware}
      Middleware is a layer of software that separates applications from their underlying platform. Middleware is often used by distributed
      systems to support heterogeneous computers and networks while offering a single-system view. Common middleware services include:
      \begin{itemize}
        \item Communication (e.g. add job to remote queue)
        \item Transactions (e.g. access multiple independent services atomically)
        \item Service composition (e.g. Independent map system enhanced with independent weather forecast system)
        \item Reliability (e.g. replicated state machine)
      \end{itemize}

    \subsection{Goals of Distributed Systems}
      \subsubsection{Supporting Resource Sharing}
        Resources can include:
        \begin{itemize}
          \item Peripheral devices (e.g. printers, video cameras)
          \item Storage facilities (e.g. file servers)
          \item Enterprise data (e.g. payroll)
          \item Web page (e.g. Web search)
          \item CPUs (e.g. Supercomputers)
        \end{itemize}

      \subsubsection{Making distribution transparent}
        Distribution transparency attempts to hide that processes and resources are physically distributed. Types of transparency include:
        \begin{itemize}
          \item \textbf{Access:} Hide differences in data representation and how data is accessed
          \item \textbf{Location:} Hide where resource is located
          \item \textbf{Migration:} Hide that a resource may move to another location
          \item \textbf{Relocation:} Hide that a resource may move to another location while in use
          \item \textbf{Replication:} Hide that a resource is replicated
          \item \textbf{Concurrency:} Hide that a resource may be shared by users competing for that resource
          \item \textbf{Failure:} Hide the failure and recovery of a resource
        \end{itemize}

      \subsubsection{Being Open}
        An open distributed system offers components that can be easily used by or integrated into other systems. Key properties of openness
        include:
        \begin{itemize}
          \item Interoperability
          \item Composability
          \item Extensibility
          \item Separation of policy from mechanism
        \end{itemize}

      \subsubsection{Being Scalable}
        Scalability covers a system's ability to expand along three axes:
        \begin{itemize}
          \item Size (e.g. adding users and resources)
          \item Geography (e.g. users across large distances)
          \item Administration (e.g. multiple independent admins)
        \end{itemize}
        Centralized systems tend to have limited scalability.

        A few common scaling techniques include:
        \begin{itemize}
          \item Hiding communication latencies (i.e. trying to avoid waiting for responses from remote-server machines)
          \item Partitioning (i.e. Taking a component, splitting it into smaller parts, and spreading those parts across the system)
          \item Replication (i.e. Adding multiple copies of a component to increase availability, balance load, support caching, etc.)
        \end{itemize}

      \subsection{Common Fallacies of Distributed Computing}
        The following are common beginner assumptions that can lead to major trouble:
        \begin{itemize}
          \item The network is reliable
          \item The network is secure
          \item The network is homogeneous
          \item The network topology is static
          \item Latency is 0
          \item Bandwidth is unlimited
          \item Transport cost is 0
          \item There is one administrator
        \end{itemize}

      \subsection{Types of Distributed Systems}
        \begin{itemize}
          \item \textbf{Web sites and Web services}
          \item \textbf{High performance computing (HPC):} High-performance computing in distributed memory settings, where message communication is used instead of shared memory.
          \item \textbf{Clustered Computing:} Distributing CPU or I/O intensive tasks over multiple servers.
          \item \textbf{Cloud and Grid Computing:} Grid computing focuses on combining resources from different institutions, while cloud computing provides access to shared pools
          of configurable system resources.
          \item \textbf{Transaction Processing:} Distributed transactions coordinated by transaction processing (TP) monitor.
          \item \textbf{Enterprise Application Integration (EAI):} Middleware often used as communication facilitator in such systems.
          \item \textbf{Sensor Networks:} Each sensor in a network can process and store data, which can be queries by some operator. Sensors often rely on in-network data
          processing to reduce communication costs.
        \end{itemize}

  \section{Architectures}
    \subsection{Definitions}
      \begin{itemize}
        \item \textbf{Component:} A modular unit with a well-defined interface
        \item \textbf{Connector:} Mechanism that mediated communication, coordination, or cooperation among components
        \item \textbf{Software architecture:} Organization of software components
        \item \textbf{System architecture:} Instantiation of software architecture in which software components are placed on real machines
        \item \textbf{Autonomic System:} System that adapts to its environment by monitoring its own behavior and reacting accordingly
      \end{itemize}

    \subsection{Architectural Styles}
      \subsubsection{Layered}
        Control flows from layer-to-layer; requests flow down the hierarchy and responses flow up, with each layer only interacting with its two neighboring layers.
        Layered architectures are often used to support client-server interactions, where a client component requests a service from a server component and waits for
        a response. Many enterprise systems are organized intro three layers, namely a user interface, application layer, and database. Note that middle layers may
        act as a client to the layer below and a server to the layer above.

        Vertical distribution describes the logical layers of a system being organized as separate physical tiers. Horizontal distribution describes a single logical
        layer being split across multiple machines.

      \subsubsection{Object-Based Architecture}
        Components are much more loosely organized than in a layered architecture, with components being able to interact freely with one another and no strict concept
        of layer.

      \subsubsection{Data-Centered Architecture}
        Components communicate by using a shared data repository, such as a database or file system.

      \subsubsection{Event-Based Architecture}
        Components communicate by sharing events. Publish/subscribe systems can be used for sharing news, balancing workloads, asynchronous workflows, etc.\\

      In practice, many systems are hybrids of the architectures listed above.

    \subsection{Self-Management:}
      Self-managing systems can be constructed using a feedback loop that monitors system behaviors and adjusts the system's internal operation.

  \section{Processes}
    \subsection{Controlling Processes in Linux}
      Below are some useful command:
      \begin{itemize}
        \item ps - lists running processes
        \item top - lists processes with top resource usage
        \item kill / pkill / killall - used to terminate processes
        \item jobs - lists currently running jobs
        \item bg - backgrounds a job
        \item fg - foregrounds a job
        \item nice / renice - sets priority of processes
        \item CTRL-C - stops job in terminal
        \item CTRL-Z - suspends job in terminal (use fg or bg to resume)
      \end{itemize}

    \subsection{Context Switching During IPC}
      Inter-process communication can be used to help coordinate processes. However, IPS can be costly, since it requires a context switch from user to
      kernel space and back.

    \subsection{Threads}
      Threads execution the same process can communicate through shared memory. Threads are sometimes referred to as lightweight processes (LWPs).
      Multithreading applications often follow a dispatcher/worker design, where a dispatcher thread received requests and feeds them to a pool
      of worker threads.

    \subsection{Hardware and Software Interfaces}
      Processes and threads may interact with underlying hardware either directly through processor instructions or indirectly through library functions
      operating system calls. The general layers of interaction (from more abstract to less) are applications, libraries, operating system and hardware.
      These layers may interact with any layer below. Distributed systems often run in virtual environments that manage interactions with lower layers.
      A major benefit of such virtualization is improved portability. Virtual machine monitors can offer additional benefits, including server consolidation,
      live migration of VMs to support load balancing and proactive maintenance, and VM replication.

    \subsection{Interfaces in Network Systems}
      Networked applications communicate by exchanging messages. The format of these messages is determined by a message-passing protocol.

    \subsection{Server Clusters}
      Servers in a cluster are often organized in three physical tiers. The first is a load balancer, followed by application servers followed by a database
      or file system.

  \section{Communication}
    \subsection{Access Transparency}
      Middleware can be used to provide access transparency for a distributed system, meaning that differences in data representation and how data is accessed
      can be hidden. This is typically done by middleware isolating the application layer from the transport layer.

    \subsection{Remote Procedure Calls (RPCs)}
      RPCs serve as the equivalent of conventional procedure calls, but for distributed systems. RPCs are implemented using a client-server protocol, where
      a client interacts with a network using a piece of software known as a client stub, and a server interacts with a network using a server stub. The
      steps of a typically RPC are detailed below:
      \begin{enumerate}
        \item Client process invokes client stub using ordinary procedure call.
        \item Client stub builds message, passes it to client OS.
        \item Client OS sends message to server OS.
        \item Server OS delivers message to server stub.
        \item Server stub unpacks parameters, invokes appropriate handler in server process.
        \item Handler processes message, returns result to server stub.
        \item Server stub packs result into message, passes it to server OS.
        \item Server OS sends message to client OS.
        \item Client OS delivers message to client stub.
        \item Client stub unpacks result, delivers it to client process.
      \end{enumerate}

      \subsubsection{Representation of Values}
        Packing parameters into a message is known as parameters marshalling (with unpacking known as demarshalling). Although data representations can be
        different across multiple machines (e.g. big-endian vs little-endian representation), the purpose of marshalling is to represent data in a
        machine-independent and network-independent format that all communicating parties expect to receive. The signatures of RPC calls can be defined
        using what is known as an interface definition language (IDL).

      \subsubsection{Synchronous vs Asynchronous}
        In a synchronous RPC, the client waits for a return value from the server before resuming execution. In an asynchronous RPC, the client may resume
        execution as soon as the server acknowledges receipt of the request (client does not need to wait for a return value). A variation of an asynchronous
        request where a client does not wait to receive any acknowledgment from the server is known as a one-way RPC.

    \subsection{Message Queuing Model} 
      As an alternative to RPCs, components in a distributed system may also communicate using a message queue that persists messages until they are consumed
      by a receiver. This technique allows for persistent communication that does not need to be tightly coupled in time. The primitive actions of a simple
      message queue are:
      \begin{itemize}
        \item \textbf{Put:} Append message to queue.
        \item \textbf{Get:} Block until queue not empty, then remove first message.
        \item \textbf{Poll:} Check specified queue for messages, remove the first message. Never block.
        \item \textbf{Notify:} Install handler to be called when message put into queue.
      \end{itemize}

      A key disadvantage of message queuing is that the delivery of the message ultimately rests with the receiver, and often cannot be guaranteed. Message
      queuing follows a design similar to publish-subscribe architectures, and is an example of message-oriented middleware (MOM).

    \subsection{Coupling Between Communicating Processes}
      \subsubsection{Referential Coupling}
        Referential coupling means that one process has to explicitly reference another one for them to communicate (e.g. connect to web server using IP
        address and port number).
      \subsubsection{Temporal Coupling}
        Temporal coupling means that processes must both be running for them to communicate (e.g. client cannot execute RPC if server is down).

  \section{Apache Thrift}
    \subsection{Overview}
      Apache Thrift is an IDL first developed by Facebook, and now managed as an open-source project in the Apache Software Foundation. Thrift provides
      a software stack and code generation engine to support RPCs between applications written in a wide variety of common languages, including C++, Java,
      Python, and PHP.

    \subsection{Thrift Software Stack}
      The elements in the Thrift software stack, from top to bottom, as as follows:
      \begin{itemize}
        \item \textbf{Server:} Sets up the lower layers of the stack, and then awaits incoming connections, which it hands off to the processor. Servers
        can be single or multi-threaded.
        \item \textbf{Processor:} Handles reading and writing IO streams, and is generated by the Thrift compiler.
        \item \textbf{Protocol:} Defined mechanism to map in-memory data structures to wire format (e.g. JSON, XML, compact binary)
        \item \textbf{Transport:} Handles reading to and writing from network (e.g. using HTTP, raw TCP, etc)
      \end{itemize}

    \subsection{Distribution Transparency}
      If Thrift clients must know the hostname and port for a given service, location transparency is violated. Also, although IDLs seek to provide access
      transparency, that too may be violated in certain conditions (e.g. when certain protocol or transport exceptions are thrown).

    \subsection{Application Protocol Versioning}
      Thrift fields can be modified and remain compatible with old versions, provided that the rules below are followed:
      \begin{itemize}
        \item Fields are associated with tag numbers, which should never the changed.
        \item New fields must be optional and provide default values.
        \item Fields no longer needed can be removed, but their tag numbers cannot be reused.
      \end{itemize}

    \subsection{Some Programming Tips}
      \begin{itemize}
        \item To separate policy from mechanism, it is generally a bad idea to hardcode hostnames and port numbers; it is usually preferable to accept command line
        arguments or use a property file.
        \item Objects built on top of TCP/IP connections (e.g. TSocket, TServerSocket) should be reused if possible to avoid to overhead of establishing and tearing
        down connections.
        \item By default Thrift transports, protocols and client stubs are not thread safe; different threads should share these items carefully, or not share them
        at all.
      \end{itemize}

\end{document}
